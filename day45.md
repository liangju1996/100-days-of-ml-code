# day45 深入研究Numpy1
## Numpy
NumPy（Numerical Python 的简称）提供了高效存储和操作密集 数据缓存的接口。
在某些方面，NumPy 数组与 Python 内置的列表类型非常相似。
但是随着数组在维度上变大，NumPy 数组提供了更加高效的存储和数据操作。
NumPy 数组几乎 是整个 Python 数据科学工具生态系统的核心。

### 1.查看numpy版本号
```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ### 2.对内置文档的提醒
 IPython 提供了快速探索包的内容的方法（用 Tab 键自动 补全），以及各种函数的文档（用 ? 符号）。
 例如，要显示 numpy 命名空间的所有内容，可以用如下方式：
 ```python
   In [3]: np.<TAB>
 ```
 要显示 NumPy 内置的文档，可以用如下方式：
 ```python
   In [4]: np?
 ```
 ### 3.在Python 中，类型是动态推断的。这意味着可以将任何类型的数据指定给任何变量,也就是不用提前定义变量类型

### 4.Python 提供了几种将数据存储在有效的、固定类型的数据缓存中的选项。内置的数组 （array）模块（在 Python 3.3 之后可用）可以用于创建统一类型的密集数组：
```python
In[6]: import array        
L = list(range(10))        
A = array.array('i', L)        
A 
 
Out[6]: array('i', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```
这里的 'i' 是一个数据类型码，表示数据为整型。
更实用的是 NumPy 包中的 ndarray 对象。Python 的数组对象提供了数组型数据的有效存储，而 NumPy 为该数据加上了高效的操作。
稍后将介绍这些操作，这里先展示几种创建 NumPy 数组的方法。
从用 np 别名导入 NumPy 的标准做法开始：
```python
In[7]: import numpy as np
```

### 5.从Python列表创建数组 
(1)首先，可以用 np.array 从 Python 列表创建数组：
 ```python
In[8]: # 整型数组:        
np.array([1, 4, 2, 5, 3]) 
 
Out[8]: array([1, 4, 2, 5, 3])
 ```
 (2)请记住，不同于 Python 列表，NumPy 要求数组必须包含同一类型的数据。如果类型不匹 配，NumPy 将会向上转换（如果可行）。这里整型被转换为浮点型：
 ```python
In[9]: np.array([3.14, 4, 2, 3]) 
 
Out[9]: array([ 3.14,  4.  ,  2.  ,  3. ])
 ```
(3)如果希望明确设置数组的数据类型，可以用 dtype 关键字：
 ```python
In[10]: np.array([1, 2, 3, 4], dtype='float32') 
 
Out[10]: array([ 1.,  2.,  3.,  4.], dtype=float32)
 ```
(4)最后，不同于 Python 列表，NumPy 数组可以被指定为多维的。以下是用列表的列表初始 化多维数组的一种方法：

 ```python
In[11]: # 嵌套列表构成的多维数组   

np.array([range(i, i + 3) for i in [2, 4, 6]]) 
 
Out[11]: array([[2, 3, 4],                 
               [4, 5, 6],                 
               [6, 7, 8]])
  ```
内层的列表被当作二维数组的行。
 
 ### 6.面对大型数组的时候，用 NumPy 内置的方法从头创建数组是一种更高效的方法。
 ```python
 In[12]: # 创建一个长度为10的数组，数组的值都是0
 np.zeros(10, dtype=int) 
 
Out[12]: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 
 
In[13]: # 创建一个3×5的浮点型数组，数组的值都是1
np.ones((3, 5), dtype=float) 
 
Out[13]: array([[ 1.,  1.,  1.,  1.,  1.],
               [ 1.,  1.,  1.,  1.,  1.],
               [ 1.,  1.,  1.,  1.,  1.]]) 
 
In[14]: # 创建一个3×5的浮点型数组，数组的值都是3.14
np.full((3, 5), 3.14) 
 
Out[14]: array([[ 3.14,  3.14,  3.14,  3.14,  3.14],
                [ 3.14,  3.14,  3.14,  3.14,  3.14], 
                [ 3.14,  3.14,  3.14,  3.14,  3.14]]) 

In[15]: # 创建一个3×5的浮点型数组，数组的值是一个线性序列
# 从0开始，到20结束，步长为2         
# （它和内置的range()函数类似）         
np.arange(0, 20, 2) 
 
Out[15]: array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18]) 
 
In[16]: # 创建一个5个元素的数组，这5个数均匀地分配到0~1        
np.linspace(0, 1, 5) 
 
Out[16]: array([ 0.  ,  0.25,  0.5 ,  0.75,  1. ]) 
 
In[17]: # 创建一个3×3的、在0~1均匀分布的随机数组成的数组         
np.random.random((3, 3)) 
 
Out[17]: array([[ 0.99844933,  0.52183819,  0.22421193],                
[ 0.08007488,  0.45429293,  0.20941444],                
[ 0.14360941,  0.96910973,  0.946117 ]]) 
 
 
In[18]: # 创建一个3×3的、均值为0、方差为1的        
# 正态分布的随机数数组         
np.random.normal(0, 1, (3, 3)) 
 
Out[18]: array([[ 1.51772646,  0.39614948, -0.10634696],                 
[ 0.25671348,  0.00732722,  0.37783601],                 
[ 0.68446945,  0.15926039, -0.70744073]]) 
 
In[19]: # 创建一个3×3的、[0, 10)区间的随机整型数组         
np.random.randint(0, 10, (3, 3)) 
 
Out[19]: array([[2, 3, 4],                 
[5, 7, 8],                 
[0, 5, 0]]) 
 
In[20]: # 创建一个3×3的单位矩阵         
np.eye(3) 
 
Out[20]: array([[ 1.,  0.,  0.],                 
[ 0.,  1.,  0.],                
[ 0.,  0.,  1.]]) 
 
In[21]: # 创建一个由3个整型数组成的未初始化的数组         
# 数组的值是内存空间中的任意值        
np.empty(3) 
 
Out[21]: array([ 1.,  1.,  1.])
 ```
 ### 7.NumPy 数组包含同一类型的值，因此详细了解这些数据类型及其限制是非常重要的。
 ### 8.NumPy数组的属性 
 我们将用 NumPy 的随机数生成器设置一组种子值，以确保每次程序执行时 都可以生成同样的随机数组：
 ```python
 In[1]: import numpy as np        
 np.random.seed(0)  # 设置随机数种子 
 
 x1 = np.random.randint(10, size=6)  # 一维数组        
 x2 = np.random.randint(10, size=(3, 4))  # 二维数组        
 x3 = np.random.randint(10, size=(3, 4, 5))  # 三维数组 
 ```
 
 每个数组有 nidm（数组的维度）、shape（数组每个维度的大小）和 size（数组的总大小）属性：
 ```python
In[2]: print("x3 ndim: ", x3.ndim)        
print("x3 shape:", x3.shape)        
print("x3 size: ", x3.size) 
 
x3 ndim:  3 
x3 shape: (3, 4, 5) 
x3 size:  60
```
另外一个有用的属性是 dtype，它是数组的数据类型（2.1 节讨论过）：
```python
In[3]: print("dtype:", x3.dtype) 
 
dtype: int64
```
其他的属性包括表示每个数组元素字节大小的 itemsize，以及表示数组总字节大小的属性 nbytes：
```python
In[4]: print("itemsize:", x3.itemsize, "bytes")        
print("nbytes:", x3.nbytes, "bytes") 
 
itemsize: 8 bytes 

nbytes: 480 bytes
```
一般来说，可以认为 nbytes 跟 itemsize 和 size 的乘积大小相等。

### 9.　数组索引：获取单个元素 
 和 Python 列表一样，在一维数组中，你也可以通过中括号指定索引获取第 i 个值（从 0 开始计数）：
 ```python
In[5]: x1 
 
Out[5]: array([5, 0, 3, 3, 7, 9]) 
 
In[6]: x1[0] 
 
Out[6]: 5 
 
In[7]: x1[4] 
 
Out[7]: 7
 ```
为了获取数组的末尾索引，可以用负值索引：
```python
In[8]: x1[-1] 
 
Out[8]: 9 
 
In[9]: x1[-2] 
 
Out[9]: 7
 ```
在多维数组中，可以用逗号分隔的索引元组获取元素：
```python
In[10]: x2 
 
Out[10]: array([[3, 5, 2, 4], 
[7, 6, 8, 8],                
[1, 6, 7, 7]]) 
 
In[11]: x2[0, 0] 
 
Out[11]: 3 
 
In[12]: x2[2, 0] 
 
Out[12]: 1 
 
In[13]: x2[2, -1] 
 
Out[13]: 7
 ```
也可以用以上索引方式修改元素值：
```python
In[14]: x2[0, 0] = 12        
x2 

Out[14]: array([[12,  5,  2,  4],                
[ 7,  6,  8,  8],                
[ 1,  6,  7,  7]])
 ```
请注意，和 Python 列表不同，NumPy 数组是固定类型的。
这意味着当你试图将一个浮点 值插入一个整型数组时，浮点值会被截短成整型。
并且这种截短是自动完成的，不会给你 提示或警告，所以需要特别注意这一点！
```python
In[15]: x1[0] = 3.14159  # 这将被截短         
x1 
 
Out[15]: array([3, 0, 3, 3, 7, 9])
 ```
 ### 10.　数组切片：获取子数组 
 我们也可以用切片（slice）符号获取子数组，切片 符号用冒号（:）表示。
 NumPy 切片语法和 Python 列表的标准切片语法相同。。为了获取数 组 x 的一个切片，可以用以下方式：
x[start:stop:step]
如果以上3 个参数都未指定，
那么它们会被分别设置默认值 start=0、stop= 维度的大小 （size of dimension）和 step=1。
1. 一维子数组 
```python
In[16]: x = np.arange(10)       
x 
 
Out[16]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 
 
In[17]: x[:5]  # 前五个元素 
 
Out[17]: array([0, 1, 2, 3, 4]) 
 
In[18]: x[5:]  # 索引五之后的元素 
 
Out[18]: array([5, 6, 7, 8, 9]) 
 
In[19]: x[4:7]  # 中间的子数组 
 
Out[19]: array([4, 5, 6]) 
 
In[20]: x[::2]  # 每隔一个元素 
 
Out[20]: array([0, 2, 4, 6, 8]) 
 
In[21]: x[1::2]  # 每隔一个元素，从索引1开始 
 
Out[21]: array([1, 3, 5, 7, 9])
```
你可能会在步长值为负时感到困惑。在这个例子中，start 参数和 stop 参数默认是被交换的。
因此这是一种非常方便的逆序数组的方式：
```python
In[22]: x[::-1]  # 所有元素，逆序的 
 
Out[22]: array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 
 
In[23]: x[5::-2]  # 从索引5开始每隔一个元素逆序 
 
Out[23]: array([5, 3, 1])
```
2. 多维子数组 
多维切片也采用同样的方式处理，用冒号分隔。例如：
```python
In[24]: x2 
 
Out[24]: array([[12,  5,  2,  4],               
[ 7,  6,  8,  8],                 
[ 1,  6,  7,  7]]) 
 
In[25]: x2[:2, :3]  # 两行，三列 
 
Out[25]: array([[12,  5,  2],               
[ 7,  6,  8]]) 
 
In[26]: x2[:3, ::2]  # 所有行，每隔一列 
 
Out[26]: array([[12,  2],               
[ 7,  8],                
[ 1,  7]])
```
最后，子数组维度也可以同时被逆序：
```python
In[27]: x2[::-1, ::-1] 
 
Out[27]: array([[ 7,  7,  6,  1],               
[ 8,  8,  6,  7],               
[ 4,  2,  5, 12]])
```
3. 获取数组的行和列 
一种常见的需求是获取数组的单行和单列。你可以将索引与切片组合起来实现这个功能，
用一个冒号（:）表示空切片：
```python
In[28]: print(x2[:, 0])  # x2的第一列 
 
[12  7  1] 
 
In[29]: print(x2[0, :])  # x2的第一行 
 
[12  5  2  4]
```
在获取行时，出于语法的简介考虑，可以省略空的切片：
```python
In[30]: print(x2[0])  #等于x2[0, :] 
 
[12  5  2  4]
```
4. 非副本视图的子数组 
关于数组切片有一点很重要也非常有用，那就是数组切片返回的是数组数据的视图，而 不是数值数据的副本。
这一点也是NumPy 数组切片和Python 列表切片的不同之处：在 Python 列表中，切片是值的副本。例如此前示例中的那个二维数组：
```python
In[31]: print(x2) 
 
[[12  5  2  4]  
[ 7  6  8  8] 
[ 1  6  7  7]]
```
从中抽取一个 2×2 的子数组：
```python
In[32]: x2_sub = x2[:2, :2]        
print(x2_sub) 
 
[[12  5]  
[ 7  6]]
```
现在如果修改这个子数组，将会看到原始数组也被修改了！结果如下所示：
```python
In[33]: x2_sub[0, 0] = 99       
print(x2_sub) 
 
[[99  5]  [ 7  6]] 
 
In[34]: print(x2) 
 
[[99  5  2  4]  [ 7  6  8  8]  [ 1  6  7  7]]
```
这种默认的处理方式实际上非常有用：它意味着在处理非常大的数据集时，可以获取或处 理这些数据集的片段，而不用复制底层的数据缓存。
5. 创建数组的副本 
尽管数组视图有一些非常好的特性，但是在有些时候明确地复制数组里的数据或子数组也 是非常有用的。可以很简单地通过 copy() 方法实现：
```python
In[35]: x2_sub_copy = x2[:2, :2].copy()      
print(x2_sub_copy) 
 
 
[[99  5]  [ 7  6]]
```
如果修改这个子数组，原始的数组不会被改变：
```python
In[36]: x2_sub_copy[0, 0] = 42       
print(x2_sub_copy) 
 
[[42  5]  [ 7  6]] 
 

In[37]: print(x2) 
 
[[99  5  2  4]  [ 7  6  8  8]  [ 1  6  7  7]]
```
### 11.数组的变形 
另一个有用的操作类型是数组的变形。数组变形最灵活的实现方式是通过 reshape() 函数 来实现。
例如，如果你希望将数字 1~9 放入一个 3×3 的矩阵中，可以采用如下方法：

```python
In[38]: grid = np.arange(1, 10).reshape((3, 3))        
print(grid) 
 
[[1 2 3]  [4 5 6]  [7 8 9]]
```
请注意，如果希望该方法可行，那么原始数组的大小必须和变形后数组的大小一致。如果 满足这个条件，reshape 方法将会用到原始数组的一个非副本视图。但实际情况是，在非 连续的数据缓存的情况下，返回非副本视图往往不可能实现。
另外一个常见的变形模式是将一个一维数组转变为二维的行或列的矩阵。你也可以通过 reshape 方法来实现，或者更简单地在一个切片操作中利用 newaxis 关键字：
```python
In[39]: x = np.array([1, 2, 3]) 
 
        # 通过变形获得的行向量       
        x.reshape((1, 3)) 
 
Out[39]: array([[1, 2, 3]]) 
 
In[40]: # 通过newaxis获得的行向量         
x[np.newaxis, :] 
 
Out[40]: array([[1, 2, 3]]) 
 
In[41]: # 通过变形获得的列向量       
x.reshape((3, 1)) 
 
Out[41]: array([[1],                
[2],              
[3]]) 
 
In[42]: # 通过newaxis获得的列向量      
x[:, np.newaxis] 
 
Out[42]: array([[1],             
[2],                
[3]])
```
在本书的其余部分中，你将看到很多这种变形。

2.2.5　数组拼接和分裂 以上所有的操作都是针对单一数组的，但有时也需要将多个数组合并为一个，或将一个数 组分裂成多个。接下来将详细介绍这些操作。
1. 数组的拼接 拼接或连接 NumPy 中的两个数组主要由 np.concatenate、np.vstack 和 np.hstack 例程实 现。np.concatenate 将数组元组或数组列表作为第一个参数，如下所示：
```python
In[43]: x = np.array([1, 2, 3])        
y = np.array([3, 2, 1])        
np.concatenate([x, y]) 
 
Out[43]: array([1, 2, 3, 3, 2, 1])
```
你也可以一次性拼接两个以上数组：
```python
In[44]: z = [99, 99, 99]        
print(np.concatenate([x, y, z])) 
 
[ 1  2  3  3  2  1 99 99 99]
np.concatenate 也可以用于二维数组的拼接：
In[45]: grid = np.array([[1, 2, 3],                       
[4, 5, 6]]) 
 
In[46]: # 沿着第一个轴拼接        
np.concatenate([grid, grid]) 
 
Out[46]: array([[1, 2, 3],                 
[4, 5, 6],               
[1, 2, 3],             
[4, 5, 6]]) 
 
 
In[47]: # 沿着第二个轴拼接（从0开始索引）         
np.concatenate([grid, grid], axis=1) 
 
Out[47]: array([[1, 2, 3, 1, 2, 3],              
[4, 5, 6, 4, 5, 6]])
```
沿着固定维度处理数组时，使用 np.vstack（垂直栈）和 np.hstack（水平栈）函数会 更简洁：
```python
In[48]: x = np.array([1, 2, 3])        
grid = np.array([[9, 8, 7],                       
[6, 5, 4]]) 
 
 # 垂直栈数组        
 np.vstack([x, grid]) 
 
Out[48]: array([[1, 2, 3],               
[9, 8, 7],                
[6, 5, 4]]) 

 
In[49]: # 水平栈数组         
y = np.array([[99],                      
[99]])         
np.hstack([grid, y]) 
 
Out[49]: array([[ 9,  8,  7, 99],                
[ 6,  5,  4, 99]])
```
与之类似，np.dstack 将沿着第三个维度拼接数组。
2. 数组的分裂 与拼接相反的过程是分裂。分裂可以通过 np.split、np.hsplit 和 np.vsplit 函数来实现。 可以向以上函数传递一个索引列表作为参数，索引列表记录的是分裂点位置：
```python
In[50]: x = [1, 2, 3, 99, 99, 3, 2, 1]         
x1, x2, x3 = np.split(x, [3, 5])        
print(x1, x2, x3) 
 
[1 2 3] [99 99] [3 2 1] 
```
值得注意的是，N 分裂点会得到 N + 1个子数组。相关的 np.hsplit 和 np.vsplit 的用法也 类似：
```python
In[51]: grid = np.arange(16).reshape((4, 4))        
grid 
 
Out[51]: array([[ 0,  1,  2,  3],                
[ 4,  5,  6,  7],                 
[ 8,  9, 10, 11],                
[12, 13, 14, 15]]) 
 
In[52]: upper, lower = np.vsplit(grid, [2])         
print(upper)        
print(lower) 
 
[[0 1 2 3]  [4 5 6 7]] [[ 8  9 10 11]  [12 13 14 15]] 
 
In[53]: left, right = np.hsplit(grid, [2])        
print(left)        
print(right) 
 
[[ 0  1] 
[ 4  5] 
[ 8  9]  
[12 13]] 
[[ 2  3]  
[ 6  7] 
[10 11] 
[14 15]]
```
同样，np.dsplit 将数组沿着第三个维度分裂。 
 
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
 ```python
 import numpy        
 numpy.__version__
 # 注意这是两条下划线
 ```
